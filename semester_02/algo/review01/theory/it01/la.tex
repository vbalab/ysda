\documentclass{article}

\usepackage[a4paper, margin=0.75in]{geometry} % Adjust margin here
\usepackage{cmap}  % should be before fontenc
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[pdftex,colorlinks=true,linkcolor=blue,urlcolor=red,unicode=true,hyperfootnotes=false,bookmarksnumbered]{hyperref}
\usepackage{indentfirst}

\newtheorem{lemma}{Лемма}  % создаёт команд для лемм
\newtheorem{theorem}{Теорема}  % создаёт команд для теорем

\newcommand{\E}{\ensuremath{\mathsf{E}}}  % матожидание
\newcommand{\D}{\ensuremath{\mathsf{D}}}  % дисперсия
\newcommand{\Prb}{\ensuremath{\mathsf{P}}}  % вероятностная мера

\newcommand{\eps}{\varepsilon}  % эпсилон
\renewcommand{\phi}{\varphi}    % фи

\renewcommand{\le}{\leqslant}   % <=
\renewcommand{\leq}{\leqslant}  % <=
\renewcommand{\ge}{\geqslant}   % >=
\renewcommand{\geq}{\geqslant}  % >=

\pagestyle{myheadings}
\markright{Владислав Балабаев, vbalab\hfill}

\begin{document}

\section{Алгоритм решения}

\begin{enumerate}
    \item \textbf{Конкатенация} строк в новую: $ S = P + ``\$`` + T $
    \item Строится \textbf{Z-функция} на $S$, где $S[i]$ равный `?' удовлетворяет условию на совпадение для любого символа.
    \item Начиная с $i=|P| + 1$ определяем \textbf{наличие вхождения} на $i-|P|$ индексе при соблюдении $Z[i]=|P|$.
\end{enumerate}

\section{Корректность}

\begin{lemma}
    Быстрее чем за $O(|P| + |T|)$ сделать нельзя.
\end{lemma}

\begin{proof}
    Следует из того, что каждый элемент обоих $P$ и $T$ должен быть учтен в алгоритме хотя бы раз, иначе элемент не участвует в проверке на совпадение.
\end{proof}

\begin{lemma}
    Использование сжимающих представлений над $T$ для такой задачи избыточно.
\end{lemma}

\begin{proof}
    Пример: $P=``??????????``$, $|T|=100.000$ состоит из уникальных комбинаций алфавита длинной в 10. Длинна строки всех комбинаций равна $10^{27}$, но достаточно любой подстроки учитывая $|T|$.

    При использовании префиксного/суффиксного дерева на $T$, помимо построения за $O(|T|)$для того, чтобы учесть `?` нужно идти во все ноды \texttt{children}, что рекурсивно вырастает в то, что все равно на поиск вхождений мы проходим все ноды дерева, то есть 100.000. Не быстрее предложенного алгоритма.
\end{proof}

\begin{theorem}
    Использование модификации Z-функции достаточно.
\end{theorem}

\begin{proof}
    Следует из нижней оценки на скорость алгоритма и скорости алгоритма модифицированной Z-функции (доказанной на лекции).
\end{proof}

\section{Временная сложность}
Каждый из пунктов алгоритма решения занимает $O(|P| + |T|)$ $\to$ $O(|P| + |T|)$ - общая сложность по времени.

\section{Затраты по памяти}
Первые два пункта $O(|P| + |T|)$ по памяти, последний $O(1)$ $\to$ $O(|P| + |T|)$ - общая сложность по дополнительной (по отношению к вводу - P и T) памяти.

\end{document}
