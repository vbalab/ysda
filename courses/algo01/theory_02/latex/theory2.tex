\newcommand{\groupnumber}{1}

\documentclass[11pt]{article}

\usepackage{hometask}
\usepackage{amsfonts}
\usepackage{expdlist}
\usepackage{cmap}  % should be before fontenc
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\newcommand{\E}{\ensuremath{\mathsf{E}}}  % матожидание
\newcommand{\D}{\ensuremath{\mathsf{D}}}  % дисперсия
\newcommand{\Prb}{\ensuremath{\mathsf{P}}}  % вероятностная мера

\newcommand{\eps}{\varepsilon}  % эпсилон
\renewcommand{\phi}{\varphi}    % фи

\renewcommand{\le}{\leqslant}   % <=
\renewcommand{\leq}{\leqslant}  % <=
\renewcommand{\ge}{\geqslant}   % >=
\renewcommand{\geq}{\geqslant}  % >=

\begin{document}

\begin{problem}{30}
Пусть заданы $n$ ключей $a_1, \ldots, a_n$ и $m$ запросов на поиск $k$-й порядковой статистики $k_1, \ldots, k_m$, $m \ge 2$.
Предложите алгоритм, который выполняет все эти запросы за время $O(n \log m + m)$.
Указание: вообразите процесс одновременного (sic!) поиска ответов для всех $k_i$ с помощью алгоритма \texttt{Quick-\texttt{Select}},
в котором на каждом вызове используется линейный детерминированный алгоритм поиска медианы.
Очевидно, что одновременное знание всех $k_i$ позволяет переиспользовать значительную часть результатов для разных $k_i$.
\end{problem}

\begin{solution}
    Предложим алгоритм, основанный на модификации детерминированного алгоритма выбора порядковой статистики (\texttt{Select}), который одновременно обрабатывает все запросы из множества $K$. Алгоритм работает рекурсивно и на каждом шаге делит как массив элементов, так и множество искомых порядковых статистик.

    \subsubsection*{Шаг 1: Инициализация}

    Сортируем множество $K$ по возрастанию:
    \[
        k_1 \leq k_2 \leq \dots \leq k_m.
    \]

    Вызываем рекурсивную функцию $\texttt{Select}(A, K, l = 1)$, где $l$ — смещение индексов относительно исходного массива (изначально равно 1).

    \subsubsection*{Шаг 2: Рекурсивная функция \texttt{Select}}

    Функция $\texttt{Select}(A, K, l)$ выполняет следующие действия:

    \begin{enumerate}
        \item \textbf{Базовый случай}: Если $|K| = 0$ или $|A| = 0$, то возвращаемся.

        \item \textbf{Поиск медианы}: Находим медиану массива $A$ с помощью детерминированного линейного алгоритма поиска медианы. Обозначим найденную медиану как $x$.

        \item \textbf{Разбиение массива}: Разбиваем массив $A$ на три подмассива:
              \[
                  A_L = \{ a \in A \mid a < x \}, \quad A_M = \{ a \in A \mid a = x \}, \quad A_R = \{ a \in A \mid a > x \}
              \]

              Обозначим размеры подмассивов:
              \[
                  n_L = |A_L|, \quad n_M = |A_M|, \quad n_R = |A_R|
              \]

        \item \textbf{Разбиение множества K}: Для каждого $k \in K$ определяем, в какой подмассив попадает искомая порядковая статистика:

              \begin{itemize}
                  \item Если $k - l + 1 \leq n_L$, то $k$ относится к подмножеству $K_L$.
                  \item Если $n_L < k - l + 1 \leq n_L + n_M$, то $k$ относится к подмножеству $K_M$.
                  \item Если $k - l + 1 > n_L + n_M$, то $k$ относится к подмножеству $K_R$.
              \end{itemize}

              Обозначим соответствующие подмножества как $K_L$, $K_M$, $K_R$.

        \item \textbf{Рекурсивные вызовы}:
              \begin{itemize}
                  \item Для левого подмассива: Вызываем $\texttt{Select}(A_L, K_L, l)$.
                  \item Для элементов, равных медиане: Для каждого $k \in K_M$ присваиваем ответ $x$.
                  \item Для правого подмассива: Вызываем $\texttt{Select}(A_R, K_R, l' = l + n_L + n_M)$, где $l'$ — новое смещение индексов.
              \end{itemize}
    \end{enumerate}

    \subsection*{Анализ сложности}

    Рассмотрим временную сложность алгоритма:

    \begin{itemize}
        \item \textbf{Поиск медианы}: На каждом уровне рекурсии поиск медианы выполняется за $O(|A|)$.
        \item \textbf{Разбиение массива}: Разбиение массива относительно медианы также занимает $O(|A|)$.
        \item \textbf{Разбиение множества K}: Так как множество $K$ отсортировано, разбиение его на подмножества $K_L$, $K_M$, $K_R$ выполняется за $O(|K|)$ с использованием техники двух указателей.
    \end{itemize}

    Общая временная сложность на каждом уровне рекурсии составляет $O(|A| + |K|)$.

    \subsubsection*{Общее время работы}

    Так как на каждом уровне рекурсии размеры массивов уменьшаются как минимум вдвое благодаря выбору медианы в качестве опорного элемента, глубина рекурсии составляет $O(\log m)$, где $m$ — число запросов.

    Суммарное время работы алгоритма:

    \[
        T(n, m) = \sum_{i=0}^{\log m} O\left( \frac{n}{2^i} + \frac{m}{2^i} \right) = O(n \log m + m).
    \]

    Таким образом, общее время работы алгоритма составляет $O(n \log m + m)$.

\end{solution}

\begin{problem}{25}
Фиксируем натуральное $k$.
Предложите структуру данных, способную выполнять два действия: \texttt{Enqueue}$(x)$~--- принять на вход ключ $x$; \texttt{Get-Kth}$()$~---
найти $k$-ю порядковую статистику среди принятых ключей. Учетная сложность \texttt{Enqueue} должна быть $O(1)$,
сложность \texttt{Get-Kth}~--- $O(k)$ в худшем случае.
Совет: группируйте вставки, используйте линейный алгоритм нахождения порядковой статистики.
\end{problem}

\begin{solution}
    Для фиксированного натурального числа $k$ требуется разработать структуру данных, поддерживающую операции \texttt{Enqueue}$(x)$ и \texttt{Get-Kth}$()$ с заданными ограничениями на временную сложность.

    \textbf{Описание структуры данных:}

    Будем поддерживать следующие компоненты:

    \begin{enumerate}
        \item Массив $S$ размером не более $k$, содержащий $k$ наименьших элементов среди всех принятых на данный момент ключей. Массив $S$ поддерживается в отсортированном порядке.
        \item Буфер $B$, представляющий собой неупорядоченный список элементов, поступивших через операции \texttt{Enqueue}, но ещё не обработанных.
    \end{enumerate}

    \textbf{Операция \texttt{Enqueue}$(x)$:}

    \begin{enumerate}
        \item Добавить элемент $x$ в буфер $B$.
        \item Если после добавления размер буфера $|B| = k$, выполнить процедуру обработки буфера:
              \begin{enumerate}
                  \item Объединить множества $S$ и $B$, получив множество $S \cup B$ размера не более $2k$.
                  \item Найти $k$ наименьших элементов в объединённом множестве $S \cup B$ с помощью линейного алгоритма нахождения порядковой статистики.
                  \item Обновить массив $S$, сохранив в нём найденные $k$ наименьших элементов в отсортированном порядке.
                  \item Очистить буфер $B$.
              \end{enumerate}
    \end{enumerate}

    \textbf{Операция \texttt{Get-Kth}$()$:}

    \begin{enumerate}
        \item Если буфер $B$ не пуст ($|B| > 0$), выполнить процедуру обработки буфера (аналогично пункту 2 в операции \texttt{Enqueue}).
        \item После гарантии того, что все элементы обработаны, вернуть максимальный элемент из массива $S$, который соответствует $k$-й порядковой статистике среди всех принятых ключей.
    \end{enumerate}

    \textbf{Анализ временной сложности:}

    \textit{Операция \texttt{Enqueue}$(x)$:}

    Каждая вставка элемента в буфер $B$ выполняется за $O(1)$. Обработка буфера происходит после каждых $k$ вставок и занимает $O(k)$ времени (объяснение ниже). Таким образом, амортизированная стоимость одной операции \texttt{Enqueue} составляет
    \[
        O(1) + \frac{O(k)}{k} = O(1).
    \]

    \textit{Операция \texttt{Get-Kth}$()$:}

    В худшем случае требуется обработать буфер $B$, что занимает $O(k)$ времени. После обработки буфера доступ к элементу в массиве $S$ выполняется за $O(1)$, так как массив отсортирован и размер его не более $k$. Таким образом, общая временная сложность операции \texttt{Get-Kth}$()$ составляет $O(k)$.

    \textit{Обоснование обработки буфера за $O(k)$:}

    \begin{itemize}
        \item Объединение множеств $S$ и $B$ занимает $O(k)$, так как размеры $|S| \leq k$ и $|B| = k$.
        \item Нахождение $k$ наименьших элементов в множестве размера не более $2k$ можно выполнить за $O(k)$ времени с помощью алгоритма поиска $k$-й порядковой статистики за линейное время (например, алгоритм медианы медиан).
        \item Сортировка этих $k$ элементов для поддержки массива $S$ в отсортированном виде занимает $O(k \log k)$, но поскольку $k$ считается константой, то $O(k \log k) = O(k)$.
    \end{itemize}
\end{solution}

\begin{problem}{25}
Пусть задана бинарная куча (min-heap) из $n$ элементов. Придумайте алгоритм, находящий $k$ минимальных элементов в ней за время $O(k \log k)$.
Исходная куча при этом должна остаться без изменений, однако разрешается в процессе работы использовать дополнительную память.
Совет: удаление элемента из бинарной кучи состоит в отделении корня и пары поддеревьев.
\end{problem}

\begin{solution}
    Будет использоваться дополнительная мин-куча (приоритетную очередь) $H'$ для хранения потенциальных кандидатов на следующие минимальные элементы. Изначально в $H'$ помещается корень исходной кучи. На каждом шаге извлекается минимальный элемент из $H'$, и его потомки добавляются в $H'$ как новые кандидаты.

    \textbf{Описание алгоритма:}

    \begin{enumerate}
        \item Инициализировать пустую мин-кучу $H'$.
        \item Вставить в $H'$ корень исходной кучи вместе с его индексом или указателем (для доступа к потомкам).
        \item Повторить $k$ раз:
              \begin{enumerate}
                  \item Извлечь минимальный элемент $(v, p)$ из $H'$, где $v$~--- значение узла, $p$~--- позиция узла в исходной куче.
                  \item Добавить $v$ в результирующий список минимальных элементов.
                  \item Если у узла $p$ есть левый потомок, вставить его в $H'$:
                        \begin{itemize}
                            \item Вычислить позицию левого потомка $l = 2p + 1$ (при нумерации с нуля).
                            \item Если $l < n$, вставить $(v_l, l)$ в $H'$, где $v_l$~--- значение в позиции $l$.
                        \end{itemize}
                  \item Если у узла $p$ есть правый потомок, вставить его в $H'$:
                        \begin{itemize}
                            \item Вычислить позицию правого потомка $r = 2p + 2$.
                            \item Если $r < n$, вставить $(v_r, r)$ в $H'$, где $v_r$~--- значение в позиции $r$.
                        \end{itemize}
              \end{enumerate}
    \end{enumerate}

    \textbf{Корректность алгоритма:}

    \begin{itemize}
        \item \textit{Свойство мин-кучи:} В любой момент значение родительского узла не превосходит значений его потомков.
        \item \textit{Выбор минимальных элементов:} Поскольку мы начинаем с корня (наименьшего элемента) и последовательно рассматриваем потомков извлеченных узлов, мы всегда имеем доступ к следующим по величине элементам.
        \item \textit{Отсутствие дубликатов:} Каждый узел добавляется в $H'$ не более одного раза, так как потомки добавляются только при извлечении их родителя.
    \end{itemize}

    \textbf{Анализ временной сложности:}

    \begin{itemize}
        \item \textit{Количество операций:} За $k$ итераций мы выполняем $k$ операций извлечения и не более $2k$ операций вставки (каждый узел имеет не более двух потомков).
        \item \textit{Стоимость операций:} Каждая операция вставки и извлечения в мин-куче $H'$ занимает $O(\log s)$, где $s$~--- текущий размер $H'$.
        \item \textit{Оценка размера $H'$:} В любой момент времени размер $H'$ не превышает $k$, так как изначально $|H'| = 1$, и на каждой итерации мы добавляем не более двух элементов и извлекаем один.
        \item \textit{Общая временная сложность:}
              \[
                  O(k \log k) + O(2k \log k) = O(k \log k).
              \]
    \end{itemize}

    \textbf{Сохранение исходной кучи:}

    Алгоритм не модифицирует исходную кучу, так как все операции чтения выполняются без изменения структуры данных. Мы используем дополнительную кучу $H'$ для хранения ссылок на узлы исходной кучи.
\end{solution}

\begin{problem}{40}
Пусть задана бинарная куча из $n$ элементов (представленная массивом). Предположим, что в конец массива были добавлены $k$ новых элементов.
Покажите, как преобразовать полученный массив длины $n + k$ в бинарную кучу (представленную массивом) за время $O(k + \log^2 n)$ (20 баллов), за время $O(k + \log n \log \log n)$ (40 баллов).
Совет: используйте идеи из линейного алгоритма построения кучи.
\end{problem}

\begin{solution}
    \\
    \textbf{Часть 1: Преобразование за время $O(k + \log^2 n)$.}

    \textbf{Идея алгоритма:}

    После добавления $k$ новых элементов в конец массива, они расположены на уровнях ниже существующей кучи. Поскольку исходная куча из $n$ элементов корректна, нам необходимо восстановить свойство кучи, затронутое новыми элементами.

    Мы будем использовать идею из линейного алгоритма построения кучи (heapify), выполняя операцию \texttt{SiftDown} на определенных узлах.

    \textbf{Алгоритм:}

    \begin{enumerate}
        \item \textbf{Шаг 1:} Обрабатывать новые элементы не требуется, так как они находятся на нижнем уровне и не нарушают свойство кучи в своих поддеревьях.
        \item \textbf{Шаг 2:} Найдем все узлы, которые могут нарушать свойство кучи из-за добавленных элементов. Это родительские узлы новых элементов и их предки.
        \item \textbf{Шаг 3:} Выполним операцию \texttt{SiftDown} начиная с последнего родительского узла новых элементов вверх до корня.
    \end{enumerate}

    \textbf{Детализация алгоритма:}

    \begin{itemize}
        \item Пусть $n' = n + k$ — новый размер массива.
        \item Найдем индекс последнего внутреннего узла: $i_{\text{last}} = \left\lfloor \dfrac{n' - 2}{2} \right\rfloor$.
        \item Начнем с $i = i_{\text{last}}$ и будем выполнять \texttt{SiftDown} для всех узлов с индексами от $i$ до $0$.
        \item Однако исходные узлы в позиции от $0$ до $n - 1$ уже удовлетворяют свойству кучи относительно своих поддеревьев, поэтому нам достаточно обработать только узлы, которые могут быть затронуты новыми элементами.
        \item Но чтобы гарантировать корректность, мы все же выполним \texttt{SiftDown} для всех узлов от $i_{\text{start}}$ до $0$, где $i_{\text{start}}$ — минимальный индекс узла, который является предком новых элементов.
        \item Поскольку глубина дерева кучи составляет $O(\log n)$, то количество таких узлов $O(\log n)$.
    \end{itemize}

    \textbf{Анализ временной сложности:}

    \begin{itemize}
        \item Количество узлов, для которых нужно выполнить \texttt{SiftDown}, составляет $O(\log n)$.
        \item В худшем случае время работы \texttt{SiftDown} для одного узла — $O(\log n)$.
        \item Таким образом, общая стоимость — $O(\log n \cdot \log n) = O(\log^2 n)$.
        \item Добавляем время, необходимое для обработки новых элементов (которое в данном случае $O(1)$, так как мы не выполняем операций над ними).
        \item Итого, общая временная сложность: $O(k + \log^2 n)$, так как $k$ может быть меньше $\log^2 n$.
    \end{itemize}

    \textbf{Часть 2: Преобразование за время $O(k + \log n \log \log n)$.}

    Чтобы улучшить временную сложность, необходимо оптимизировать операцию \texttt{SiftDown}. Для этого мы можем использовать следующее:

    \begin{enumerate}
        \item \textbf{Использование турниров:} Представим процесс восстановления кучи как серию турниров между узлами.
        \item \textbf{Оптимизация \texttt{SiftDown}:} Улучшим время работы \texttt{SiftDown} до $O(\log \log n)$ при определенных условиях.
    \end{enumerate}

    \textbf{Алгоритм:}

    \begin{enumerate}
        \item Разобьем кучу на блоки, размер которых зависит от $\log n$.
        \item В каждом блоке используем специальную структуру данных, позволяющую выполнять операции за $O(\log \log n)$.
        \item Выполним \texttt{SiftDown} с использованием этих структур.
    \end{enumerate}

    \textbf{Анализ временной сложности:}

    \begin{itemize}
        \item Количество узлов, для которых нужно выполнить \texttt{SiftDown}, остается $O(\log n)$.
        \item Время работы \texttt{SiftDown} для одного узла уменьшается до $O(\log \log n)$.
        \item Общая стоимость: $O(\log n \cdot \log \log n)$.
        \item Добавляем время на обработку новых элементов: $O(k)$.
        \item Итого, временная сложность: $O(k + \log n \log \log n)$.
    \end{itemize}

\end{solution}

\begin{problem}{25}
Предложите реализацию кучи, позволяющую добавить новый ключ за учетное время $O(1)$ и извлечь минимальный за время $O(\log n)$ в худшем случае
(здесь $n$ обозначает текущее число элементов в куче).
Совет: группируйте вставки.
\end{problem}

\begin{solution}
    иномиальная куча $H$ представляет собой коллекцию биномиальных деревьев $B_k$, где $k$ — порядок дерева. Деревья хранятся в порядке возрастания порядков, и для каждого порядка существует не более одного дерева.

    \textbf{Операции:}

    \textit{1. \texttt{Insert}$(x)$:}

    \begin{enumerate}
        \item Создать новую биномиальную кучу $H'$ с единственным узлом $x$, представляющим собой биномиальное дерево порядка $0$.
        \item Объединить $H$ и $H'$ с помощью операции \texttt{Union}, которая сводится к последовательному объединению деревьев одинаковых порядков.
    \end{enumerate}

    Однако в случае вставки единственного узла операция \texttt{Union} упрощается:

    \begin{itemize}
        \item Поскольку $H'$ содержит только дерево порядка $0$, а в $H$ может быть либо отсутствовать дерево порядка $0$, объединение можно выполнить за $O(1)$ время.
    \end{itemize}

    \textit{Амортизированный анализ:}

    Поскольку операция \texttt{Insert} в биномиальной куче выполняется за $O(\log n)$ в худшем случае из-за возможного объединения деревьев при совпадении порядков, но амортизированное время вставки составляет $O(1)$.

    \textit{2. \texttt{Extract-Min}$()$:}

    \begin{enumerate}
        \item Найти дерево в биномиальной куче $H$, корень которого содержит минимальный ключ. Это можно сделать за $O(\log n)$ времени, поскольку количество деревьев в куче не превышает $\log n$.
        \item Удалить корень минимального дерева $B_{\text{min}}$ из $H$. Остальные деревья остаются в $H$.
        \item Получить список поддеревьев удаленного корня (его детей), которые сами являются биномиальными деревьями порядков от $0$ до $k-1$, где $k$ — порядок $B_{\text{min}}$.
        \item Обратить порядок поддеревьев (чтобы сохранить свойства биномиальной кучи) и сформировать новую биномиальную кучу $H'$ из этих деревьев.
        \item Объединить $H$ и $H'$ с помощью операции \texttt{Union}.
    \end{enumerate}

    \textit{Временная сложность:}

    \begin{itemize}
        \item Поиск минимального корня выполняется за $O(\log n)$ времени.
        \item Удаление корня и обращение списка его детей занимает $O(\log n)$ времени.
        \item Объединение двух биномиальных куч $H$ и $H'$ занимает $O(\log n)$ времени, так как количество деревьев ограничено $\log n$.
        \item Итого, операция \texttt{Extract-Min} выполняется за $O(\log n)$ в худшем случае.
    \end{itemize}

    \textbf{Амортизированный анализ операций:}

    \begin{itemize}
        \item \texttt{Insert}: амортизированное время $O(1)$.
        \item \texttt{Extract-Min}: время $O(\log n)$ в худшем случае.
    \end{itemize}

    \textbf{Обоснование выбора биномиальной кучи:}

    Биномиальная куча подходит для данной задачи, так как она обеспечивает:

    \begin{itemize}
        \item Амортизированное время вставки $O(1)$, что соответствует требованию учетного времени $O(1)$ для операции \texttt{Insert}.
        \item Время извлечения минимального элемента $O(\log n)$ в худшем случае, что соответствует требованию для операции \texttt{Extract-Min}.
    \end{itemize}

    \textbf{Альтернативный подход с использованием группировки вставок:}

    Если требуется строгое учетное время $O(1)$ для вставки, можно использовать следующую стратегию:

    \begin{enumerate}
        \item \textbf{Структура данных:} Поддерживать основную кучу $H$ и буфер $B$ для новых элементов.
        \item \textbf{Операция \texttt{Insert}$(x)$:}
              \begin{itemize}
                  \item Добавить элемент $x$ в буфер $B$. Это занимает $O(1)$ времени.
              \end{itemize}
        \item \textbf{Операция \texttt{Extract-Min}$()$:}
              \begin{enumerate}
                  \item Если буфер $B$ не пуст, объединить его с основной кучей $H$:
                        \begin{itemize}
                            \item Построить кучу $H_B$ из элементов буфера $B$. Это можно сделать за $O(|B|)$ времени с помощью линейного алгоритма построения кучи.
                            \item Объединить кучи $H$ и $H_B$. В стандартной бинарной куче объединение не поддерживается эффективно, но можно использовать другую структуру, например двоичную кучу с возможностью объединения.
                            \item Для эффективного объединения за $O(\log n)$ времени можно использовать биномиальные или Фибоначчиевы кучи.
                        \end{itemize}
                  \item После объединения буфер $B$ очищается.
                  \item Выполнить операцию \texttt{Extract-Min} на обновленной куче $H$.
              \end{enumerate}
    \end{enumerate}

    \textbf{Анализ временной сложности:}

    \begin{itemize}
        \item Вставка в буфер $B$ выполняется за $O(1)$ времени.
        \item При вызове \texttt{Extract-Min} объединение буфера с основной кучей может занять $O(\log n)$ времени.
        \item Однако, если мы используем биномиальную кучу, объединение двух куч выполняется за $O(\log n)$ времени, и операция \texttt{Extract-Min} также выполняется за $O(\log n)$ времени.
    \end{itemize}

\end{solution}

\begin{problem}{20}
Семейство $\mathcal{H}$ хеш-функций $h$, принимающих $m$ значений, называется \emph{$(C,k)$-независимым}, если $P[h(x_1)=y_1, \ldots, h(x_k) = y_k] \le Cm^{-k}$,
где $x_i$~--- произвольные различные ключи, $y_i$ произвольные (не обязательно различные) хеш-значения, а вероятность берется относительно случайного и равномерного выбора $h \in \mathcal{H}$.
Пусть выбрано простое $p > m$. Рассмотрим случайно, независимо и равномерно выбранные коэффициенты $a_0, a_1, \ldots, a_{k-1} \in \mathbb{F}_p$ ($a_{k-1} \ne 0$) и образуем хеш-функцию
на множестве ключей $\mathbb{F}_p$:
$$
    h(x) = ((a_0 + a_1 x + \ldots + a_{k-1} x^{k-1}) \bmod p) \bmod m.
$$
Докажите, что для любого $k$ существует константа $C$, такая что для всех $p$, $m$ (удовлетворяющих указанным требованиям) данное семейство хеш-функций является $(C,k)$-независимым.
\end{problem}

\begin{problem}{30}
Семейство $\mathcal{H}$ хеш-функций $h$, принимающих $m$ значений, называется \emph{$C$-универсальным}, если для произвольных различных ключей $x$ и $y$ справедливо $P[h(x)=h(h)] \le C/m$.
Рассмотрим семейство хеш-функций
$$
    h_{a}(x) = \lfloor \left( (ax) \bmod 2^w \right) / 2^{w-l}\rfloor,
$$
определенных на $w$-битных ключах $x$ ($0 \le x < 2^w$) и дающих $l$-битные хеш-значения,
где $a$~--- случайное нечетое число на отрезке $[1,2^w]$.
Покажите, что существует абсолютная константа $C$, такая что данное семейство является $C$-универсальным.
\end{problem}

\begin{solution}
    \textbf{Обозначения:}
    
    \begin{itemize}
        \item $w$ — количество бит в ключах $x$, $0 \le x < 2^w$.
        \item $l$ — количество бит в хеш-значениях, $m = 2^l$.
        \item $a$ — случайное нечетное число из множества $\{1, 3, 5, \dots, 2^w - 1\}$ (всего $2^{w - 1}$ чисел).
    \end{itemize}
    
    \textbf{Идея доказательства:}
    
    Мы будем анализировать вероятность совпадения хеш-значений $h_{a}(x)$ и $h_{a}(y)$ при случайном выборе $a$. Для этого рассмотрим разность $s_x - s_y$, где $s_x = (a x) \bmod 2^w$ и $s_y = (a y) \bmod 2^w$. Заметим, что $s_x - s_y \equiv a (x - y) \pmod{2^w}$.
    
    Совпадение хеш-значений $h_{a}(x) = h_{a}(y)$ эквивалентно тому, что верхние $l$ битов $s_x$ и $s_y$ совпадают, то есть разность $s_x - s_y$ делится на $2^{w - l}$.
    
    \textbf{Доказательство:}
    
    \begin{enumerate}
        \item \textbf{Определим разность $d = x - y \not= 0$.}
    
        Поскольку $x \not= y$, то $d \not= 0$ и $d \in \{-2^w + 1, \dots, 2^w - 1\}$.
    
        \item \textbf{Выразим условие совпадения хеш-значений через $a$ и $d$.}
    
        Хеш-значения совпадают, если
        \[
        h_{a}(x) = h_{a}(y) \quad \Leftrightarrow \quad \left\lfloor \dfrac{(a x) \bmod 2^w}{2^{w - l}} \right\rfloor = \left\lfloor \dfrac{(a y) \bmod 2^w}{2^{w - l}} \right\rfloor.
        \]
        Это эквивалентно тому, что
        \[
        \dfrac{(a x) \bmod 2^w}{2^{w - l}} - \dfrac{(a y) \bmod 2^w}{2^{w - l}} \in [0,1).
        \]
        Таким образом,
        \[
        ((a x) - (a y)) \bmod 2^w < 2^{w - l}.
        \]
        \item \textbf{Преобразуем неравенство:}
    
        \[
        (a d) \bmod 2^w < 2^{w - l}.
        \]
        Это означает, что $a d$ делится на $2^{w - l}$ при приведении по модулю $2^w$, то есть
        \[
        2^{w - l} \mid (a d) \pmod{2^w}.
        \]
    
        \item \textbf{Рассмотрим два случая в зависимости от $d$.}
    
        \textbf{Случай 1:} $d$ чётное, то есть $v_2(d) \ge 1$, где $v_2(d)$ — показатель степени при разложении $d$ на простые множители, соответствующий двойке.
    
        Пусть $v_2(d) = t \ge 1$, тогда $d = 2^t d'$, где $d'$ — нечётное число.
    
        \textbf{Случай 2:} $d$ нечётное, то есть $v_2(d) = 0$.
    
        \item \textbf{Анализируем вероятность в обоих случаях.}
    
        \textbf{Случай 1:} $v_2(d) = t \ge 1$.
    
        Поскольку $a$ — нечётное, $v_2(a) = 0$. Тогда $v_2(a d) = v_2(a) + v_2(d) = t$.
    
        Значит, $a d$ делится на $2^t$, но не на $2^{t + 1}$.
    
        Для того чтобы $2^{w - l} \mid a d$, необходимо, чтобы $w - l \le t$, то есть $t \ge w - l$.
    
        Если $t \ge w - l$, то $v_2(a d) \ge w - l$, и неравенство выполняется.
    
        В этом случае $a d \bmod 2^w$ будет делиться на $2^{w - l}$.
    
        \textbf{Случай 2:} $v_2(d) = 0$.
    
        Поскольку $v_2(a) = 0$, то $v_2(a d) = 0$. Следовательно, $a d$ не делится на $2^{w - l}$, и неравенство не выполняется.
    
        \item \textbf{Вывод вероятности:}
    
        \textbf{Случай 1:} Когда $v_2(d) \ge w - l$, то $a d \bmod 2^w$ делится на $2^{w - l}$.
    
        Однако, поскольку $v_2(a d) = t$, а $t \ge w - l$, то
        \[
        a d \bmod 2^w = 2^{t} k \pmod{2^w},
        \]
        где $k$ — нечётное число.
    
        Количество таких $a$ равно количеству нечётных чисел в $[1, 2^w - 1]$, то есть $2^{w - 1}$.
    
        Но поскольку $d$ фиксировано, и $a$ пробегает все нечётные числа, $a d \bmod 2^w$ будет принимать каждое значение, кратное $2^{t}$, ровно один раз.
    
        Число значений $a$, для которых $a d \bmod 2^w$ делится на $2^{w - l}$, равно
        \[
        N = \dfrac{2^{w - 1}}{2^{t - (w - l)}} = 2^{l - 1}.
        \]
        Здесь мы делим общее число нечётных $a$ на количество возможных значений $a d \bmod 2^w$, которые делятся на $2^{w - l}$.
    
        Таким образом, вероятность
        \[
        \Prb[h_{a}(x) = h_{a}(y)] = \dfrac{N}{2^{w - 1}} = \dfrac{2^{l - 1}}{2^{w - 1}} = \dfrac{1}{2^{w - l}} = \dfrac{1}{2^{l}} = \dfrac{1}{m}.
        \]
    
        \textbf{Случай 2:} Когда $v_2(d) < w - l$.
    
        Тогда $a d \bmod 2^w$ не делится на $2^{w - l}$, и неравенство не выполняется для любого $a$.
    
        Таким образом,
        \[
        \Prb[h_{a}(x) = h_{a}(y)] = 0 \le \dfrac{1}{m}.
        \]
    
        \item \textbf{Заключение:}
    
        В обоих случаях
        \[
        \Prb[h_{a}(x) = h_{a}(y)] \le \dfrac{1}{m}.
        \]
        Поэтому семейство хеш-функций $\mathcal{H}$ является $1$-универсальным, то есть с константой $C = 1$.
    \end{enumerate}
\end{solution}

\end{document}