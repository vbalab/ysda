\newcommand{\groupnumber}{1}

\documentclass[11pt]{article}

\usepackage{hometask}
\usepackage{amsfonts}
\usepackage{expdlist}
\usepackage{cmap}  % should be before fontenc
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\newcommand{\E}{\ensuremath{\mathsf{E}}}  % матожидание
\newcommand{\D}{\ensuremath{\mathsf{D}}}  % дисперсия
\newcommand{\Prb}{\ensuremath{\mathsf{P}}}  % вероятностная мера

\newcommand{\eps}{\varepsilon}  % эпсилон
\renewcommand{\phi}{\varphi}    % фи

\renewcommand{\le}{\leqslant}   % <=
\renewcommand{\leq}{\leqslant}  % <=
\renewcommand{\ge}{\geqslant}   % >=
\renewcommand{\geq}{\geqslant}  % >=

\begin{document}

\begin{problem}{25}
Пусть задана бинарная куча (min-heap) из $n$ элементов. Придумайте алгоритм, находящий $k$ минимальных элементов в ней за время $O(k \log k)$.
Исходная куча при этом должна остаться без изменений, однако разрешается в процессе работы использовать дополнительную память.
Совет: удаление элемента из бинарной кучи состоит в отделении корня и пары поддеревьев.
\end{problem}

\begin{solution}
    Будет использоваться дополнительная мин-куча (приоритетную очередь) $H'$ для хранения потенциальных кандидатов на следующие минимальные элементы. Изначально в $H'$ помещается корень исходной кучи. На каждом шаге извлекается минимальный элемент из $H'$, и его потомки добавляются в $H'$ как новые кандидаты.

    \textbf{Описание алгоритма:}

    \begin{enumerate}
        \item Инициализировать пустую мин-кучу $H'$.
        \item Вставить в $H'$ корень исходной кучи вместе с его индексом или указателем (для доступа к потомкам).
        \item Повторить $k$ раз:
              \begin{enumerate}
                  \item Извлечь минимальный элемент $(v, p)$ из $H'$, где $v$~--- значение узла, $p$~--- позиция узла в исходной куче.
                  \item Добавить $v$ в результирующий список минимальных элементов.
                  \item Если у узла $p$ есть левый потомок, вставить его в $H'$:
                        \begin{itemize}
                            \item Вычислить позицию левого потомка $l = 2p + 1$ (при нумерации с нуля).
                            \item Если $l < n$, вставить $(v_l, l)$ в $H'$, где $v_l$~--- значение в позиции $l$.
                        \end{itemize}
                  \item Если у узла $p$ есть правый потомок, вставить его в $H'$:
                        \begin{itemize}
                            \item Вычислить позицию правого потомка $r = 2p + 2$.
                            \item Если $r < n$, вставить $(v_r, r)$ в $H'$, где $v_r$~--- значение в позиции $r$.
                        \end{itemize}
              \end{enumerate}
    \end{enumerate}

    \textbf{Корректность алгоритма:}

    \begin{itemize}
        \item \textit{Свойство мин-кучи:} В любой момент значение родительского узла не превосходит значений его потомков.
        \item \textit{Выбор минимальных элементов:} Поскольку мы начинаем с корня (наименьшего элемента) и последовательно рассматриваем потомков извлеченных узлов, мы всегда имеем доступ к следующим по величине элементам.
        \item \textit{Отсутствие дубликатов:} Каждый узел добавляется в $H'$ не более одного раза, так как потомки добавляются только при извлечении их родителя.
    \end{itemize}

    \textbf{Анализ временной сложности:}

    \begin{itemize}
        \item \textit{Количество операций:} За $k$ итераций мы выполняем $k$ операций извлечения и не более $2k$ операций вставки (каждый узел имеет не более двух потомков).
        \item \textit{Стоимость операций:} Каждая операция вставки и извлечения в мин-куче $H'$ занимает $O(\log s)$, где $s$~--- текущий размер $H'$.
        \item \textit{Оценка размера $H'$:} В любой момент времени размер $H'$ не превышает $k$, так как изначально $|H'| = 1$, и на каждой итерации мы добавляем не более двух элементов и извлекаем один.
        \item \textit{Общая временная сложность:}
              \[
                  O(k \log k) + O(2k \log k) = O(k \log k).
              \]
    \end{itemize}

    \textbf{Сохранение исходной кучи:}

    Алгоритм не модифицирует исходную кучу, так как все операции чтения выполняются без изменения структуры данных. Мы используем дополнительную кучу $H'$ для хранения ссылок на узлы исходной кучи.
\end{solution}

\end{document}