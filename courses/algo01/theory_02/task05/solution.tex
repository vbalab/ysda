\newcommand{\groupnumber}{1}

\documentclass[11pt]{article}

\usepackage{hometask}
\usepackage{amsfonts}
\usepackage{expdlist}
\usepackage{cmap}  % should be before fontenc
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\newcommand{\E}{\ensuremath{\mathsf{E}}}  % матожидание
\newcommand{\D}{\ensuremath{\mathsf{D}}}  % дисперсия
\newcommand{\Prb}{\ensuremath{\mathsf{P}}}  % вероятностная мера

\newcommand{\eps}{\varepsilon}  % эпсилон
\renewcommand{\phi}{\varphi}    % фи

\renewcommand{\le}{\leqslant}   % <=
\renewcommand{\leq}{\leqslant}  % <=
\renewcommand{\ge}{\geqslant}   % >=
\renewcommand{\geq}{\geqslant}  % >=

\begin{document}

\begin{problem}{25}
Предложите реализацию кучи, позволяющую добавить новый ключ за учетное время $O(1)$ и извлечь минимальный за время $O(\log n)$ в худшем случае
(здесь $n$ обозначает текущее число элементов в куче).
Совет: группируйте вставки.
\end{problem}

\begin{solution}
    иномиальная куча $H$ представляет собой коллекцию биномиальных деревьев $B_k$, где $k$ — порядок дерева. Деревья хранятся в порядке возрастания порядков, и для каждого порядка существует не более одного дерева.

    \textbf{Операции:}

    \textit{1. \texttt{Insert}$(x)$:}

    \begin{enumerate}
        \item Создать новую биномиальную кучу $H'$ с единственным узлом $x$, представляющим собой биномиальное дерево порядка $0$.
        \item Объединить $H$ и $H'$ с помощью операции \texttt{Union}, которая сводится к последовательному объединению деревьев одинаковых порядков.
    \end{enumerate}

    Однако в случае вставки единственного узла операция \texttt{Union} упрощается:

    \begin{itemize}
        \item Поскольку $H'$ содержит только дерево порядка $0$, а в $H$ может быть либо отсутствовать дерево порядка $0$, объединение можно выполнить за $O(1)$ время.
    \end{itemize}

    \textit{Амортизированный анализ:}

    Поскольку операция \texttt{Insert} в биномиальной куче выполняется за $O(\log n)$ в худшем случае из-за возможного объединения деревьев при совпадении порядков, но амортизированное время вставки составляет $O(1)$.

    \textit{2. \texttt{Extract-Min}$()$:}

    \begin{enumerate}
        \item Найти дерево в биномиальной куче $H$, корень которого содержит минимальный ключ. Это можно сделать за $O(\log n)$ времени, поскольку количество деревьев в куче не превышает $\log n$.
        \item Удалить корень минимального дерева $B_{\text{min}}$ из $H$. Остальные деревья остаются в $H$.
        \item Получить список поддеревьев удаленного корня (его детей), которые сами являются биномиальными деревьями порядков от $0$ до $k-1$, где $k$ — порядок $B_{\text{min}}$.
        \item Обратить порядок поддеревьев (чтобы сохранить свойства биномиальной кучи) и сформировать новую биномиальную кучу $H'$ из этих деревьев.
        \item Объединить $H$ и $H'$ с помощью операции \texttt{Union}.
    \end{enumerate}

    \textit{Временная сложность:}

    \begin{itemize}
        \item Поиск минимального корня выполняется за $O(\log n)$ времени.
        \item Удаление корня и обращение списка его детей занимает $O(\log n)$ времени.
        \item Объединение двух биномиальных куч $H$ и $H'$ занимает $O(\log n)$ времени, так как количество деревьев ограничено $\log n$.
        \item Итого, операция \texttt{Extract-Min} выполняется за $O(\log n)$ в худшем случае.
    \end{itemize}

    \textbf{Амортизированный анализ операций:}

    \begin{itemize}
        \item \texttt{Insert}: амортизированное время $O(1)$.
        \item \texttt{Extract-Min}: время $O(\log n)$ в худшем случае.
    \end{itemize}

    \textbf{Обоснование выбора биномиальной кучи:}

    Биномиальная куча подходит для данной задачи, так как она обеспечивает:

    \begin{itemize}
        \item Амортизированное время вставки $O(1)$, что соответствует требованию учетного времени $O(1)$ для операции \texttt{Insert}.
        \item Время извлечения минимального элемента $O(\log n)$ в худшем случае, что соответствует требованию для операции \texttt{Extract-Min}.
    \end{itemize}

    \textbf{Альтернативный подход с использованием группировки вставок:}

    Если требуется строгое учетное время $O(1)$ для вставки, можно использовать следующую стратегию:

    \begin{enumerate}
        \item \textbf{Структура данных:} Поддерживать основную кучу $H$ и буфер $B$ для новых элементов.
        \item \textbf{Операция \texttt{Insert}$(x)$:}
              \begin{itemize}
                  \item Добавить элемент $x$ в буфер $B$. Это занимает $O(1)$ времени.
              \end{itemize}
        \item \textbf{Операция \texttt{Extract-Min}$()$:}
              \begin{enumerate}
                  \item Если буфер $B$ не пуст, объединить его с основной кучей $H$:
                        \begin{itemize}
                            \item Построить кучу $H_B$ из элементов буфера $B$. Это можно сделать за $O(|B|)$ времени с помощью линейного алгоритма построения кучи.
                            \item Объединить кучи $H$ и $H_B$. В стандартной бинарной куче объединение не поддерживается эффективно, но можно использовать другую структуру, например двоичную кучу с возможностью объединения.
                            \item Для эффективного объединения за $O(\log n)$ времени можно использовать биномиальные или Фибоначчиевы кучи.
                        \end{itemize}
                  \item После объединения буфер $B$ очищается.
                  \item Выполнить операцию \texttt{Extract-Min} на обновленной куче $H$.
              \end{enumerate}
    \end{enumerate}

    \textbf{Анализ временной сложности:}

    \begin{itemize}
        \item Вставка в буфер $B$ выполняется за $O(1)$ времени.
        \item При вызове \texttt{Extract-Min} объединение буфера с основной кучей может занять $O(\log n)$ времени.
        \item Однако, если мы используем биномиальную кучу, объединение двух куч выполняется за $O(\log n)$ времени, и операция \texttt{Extract-Min} также выполняется за $O(\log n)$ времени.
    \end{itemize}

\end{solution}

\end{document}