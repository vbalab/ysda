\newcommand{\groupnumber}{1}

\documentclass[11pt]{article}

\usepackage{hometask}
\usepackage{amsfonts}
\usepackage{expdlist}
\usepackage{cmap}  % should be before fontenc
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\newcommand{\E}{\ensuremath{\mathsf{E}}}  % матожидание
\newcommand{\D}{\ensuremath{\mathsf{D}}}  % дисперсия
\newcommand{\Prb}{\ensuremath{\mathsf{P}}}  % вероятностная мера

\newcommand{\eps}{\varepsilon}  % эпсилон
\renewcommand{\phi}{\varphi}    % фи

\renewcommand{\le}{\leqslant}   % <=
\renewcommand{\leq}{\leqslant}  % <=
\renewcommand{\ge}{\geqslant}   % >=
\renewcommand{\geq}{\geqslant}  % >=

\begin{document}

\begin{problem}{30}
Пусть заданы $n$ ключей $a_1, \ldots, a_n$ и $m$ запросов на поиск $k$-й порядковой статистики $k_1, \ldots, k_m$, $m \ge 2$.
Предложите алгоритм, который выполняет все эти запросы за время $O(n \log m + m)$.
Указание: вообразите процесс одновременного (sic!) поиска ответов для всех $k_i$ с помощью алгоритма \texttt{Quick-\texttt{Select}},
в котором на каждом вызове используется линейный детерминированный алгоритм поиска медианы.
Очевидно, что одновременное знание всех $k_i$ позволяет переиспользовать значительную часть результатов для разных $k_i$.
\end{problem}

\begin{solution}
    Предложим алгоритм, основанный на модификации детерминированного алгоритма выбора порядковой статистики (\texttt{Select}), который одновременно обрабатывает все запросы из множества $K$. Алгоритм работает рекурсивно и на каждом шаге делит как массив элементов, так и множество искомых порядковых статистик.

    \subsubsection*{Шаг 1: Инициализация}

    Сортируем множество $K$ по возрастанию:
    \[
        k_1 \leq k_2 \leq \dots \leq k_m.
    \]

    Вызываем рекурсивную функцию $\texttt{Select}(A, K, l = 1)$, где $l$ — смещение индексов относительно исходного массива (изначально равно 1).

    \subsubsection*{Шаг 2: Рекурсивная функция \texttt{Select}}

    Функция $\texttt{Select}(A, K, l)$ выполняет следующие действия:

    \begin{enumerate}
        \item \textbf{Базовый случай}: Если $|K| = 0$ или $|A| = 0$, то возвращаемся.

        \item \textbf{Поиск медианы}: Находим медиану массива $A$ с помощью детерминированного линейного алгоритма поиска медианы. Обозначим найденную медиану как $x$.

        \item \textbf{Разбиение массива}: Разбиваем массив $A$ на три подмассива:
              \[
                  A_L = \{ a \in A \mid a < x \}, \quad A_M = \{ a \in A \mid a = x \}, \quad A_R = \{ a \in A \mid a > x \}
              \]

              Обозначим размеры подмассивов:
              \[
                  n_L = |A_L|, \quad n_M = |A_M|, \quad n_R = |A_R|
              \]

        \item \textbf{Разбиение множества K}: Для каждого $k \in K$ определяем, в какой подмассив попадает искомая порядковая статистика:

              \begin{itemize}
                  \item Если $k - l + 1 \leq n_L$, то $k$ относится к подмножеству $K_L$.
                  \item Если $n_L < k - l + 1 \leq n_L + n_M$, то $k$ относится к подмножеству $K_M$.
                  \item Если $k - l + 1 > n_L + n_M$, то $k$ относится к подмножеству $K_R$.
              \end{itemize}

              Обозначим соответствующие подмножества как $K_L$, $K_M$, $K_R$.

        \item \textbf{Рекурсивные вызовы}:
              \begin{itemize}
                  \item Для левого подмассива: Вызываем $\texttt{Select}(A_L, K_L, l)$.
                  \item Для элементов, равных медиане: Для каждого $k \in K_M$ присваиваем ответ $x$.
                  \item Для правого подмассива: Вызываем $\texttt{Select}(A_R, K_R, l' = l + n_L + n_M)$, где $l'$ — новое смещение индексов.
              \end{itemize}
    \end{enumerate}

    \subsection*{Анализ сложности}

    Рассмотрим временную сложность алгоритма:

    \begin{itemize}
        \item \textbf{Поиск медианы}: На каждом уровне рекурсии поиск медианы выполняется за $O(|A|)$.
        \item \textbf{Разбиение массива}: Разбиение массива относительно медианы также занимает $O(|A|)$.
        \item \textbf{Разбиение множества K}: Так как множество $K$ отсортировано, разбиение его на подмножества $K_L$, $K_M$, $K_R$ выполняется за $O(|K|)$ с использованием техники двух указателей.
    \end{itemize}

    Общая временная сложность на каждом уровне рекурсии составляет $O(|A| + |K|)$.

    \subsubsection*{Общее время работы}

    Так как на каждом уровне рекурсии размеры массивов уменьшаются как минимум вдвое благодаря выбору медианы в качестве опорного элемента, глубина рекурсии составляет $O(\log m)$, где $m$ — число запросов.

    Суммарное время работы алгоритма:

    \[
        T(n, m) = \sum_{i=0}^{\log m} O\left( \frac{n}{2^i} + \frac{m}{2^i} \right) = O(n \log m + m).
    \]

    Таким образом, общее время работы алгоритма составляет $O(n \log m + m)$.

\end{solution}

\end{document}