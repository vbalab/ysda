\newcommand{\groupnumber}{1}

\documentclass[11pt]{article}

\usepackage{hometask}
\usepackage{amsfonts}
\usepackage{expdlist}
\usepackage{cmap}  % should be before fontenc
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\newcommand{\E}{\ensuremath{\mathsf{E}}}  % матожидание
\newcommand{\D}{\ensuremath{\mathsf{D}}}  % дисперсия
\newcommand{\Prb}{\ensuremath{\mathsf{P}}}  % вероятностная мера

\newcommand{\eps}{\varepsilon}  % эпсилон
\renewcommand{\phi}{\varphi}    % фи

\renewcommand{\le}{\leqslant}   % <=
\renewcommand{\leq}{\leqslant}  % <=
\renewcommand{\ge}{\geqslant}   % >=
\renewcommand{\geq}{\geqslant}  % >=

\begin{document}

\begin{problem}{40}
Пусть задана бинарная куча из $n$ элементов (представленная массивом). Предположим, что в конец массива были добавлены $k$ новых элементов.
Покажите, как преобразовать полученный массив длины $n + k$ в бинарную кучу (представленную массивом) за время $O(k + \log^2 n)$ (20 баллов), за время $O(k + \log n \log \log n)$ (40 баллов).
Совет: используйте идеи из линейного алгоритма построения кучи.
\end{problem}

\begin{solution}
    \\
    \textbf{Часть 1: Преобразование за время $O(k + \log^2 n)$.}

    \textbf{Идея алгоритма:}

    После добавления $k$ новых элементов в конец массива, они расположены на уровнях ниже существующей кучи. Поскольку исходная куча из $n$ элементов корректна, нам необходимо восстановить свойство кучи, затронутое новыми элементами.

    Мы будем использовать идею из линейного алгоритма построения кучи (heapify), выполняя операцию \texttt{SiftDown} на определенных узлах.

    \textbf{Алгоритм:}

    \begin{enumerate}
        \item \textbf{Шаг 1:} Обрабатывать новые элементы не требуется, так как они находятся на нижнем уровне и не нарушают свойство кучи в своих поддеревьях.
        \item \textbf{Шаг 2:} Найдем все узлы, которые могут нарушать свойство кучи из-за добавленных элементов. Это родительские узлы новых элементов и их предки.
        \item \textbf{Шаг 3:} Выполним операцию \texttt{SiftDown} начиная с последнего родительского узла новых элементов вверх до корня.
    \end{enumerate}

    \textbf{Детализация алгоритма:}

    \begin{itemize}
        \item Пусть $n' = n + k$ — новый размер массива.
        \item Найдем индекс последнего внутреннего узла: $i_{\text{last}} = \left\lfloor \dfrac{n' - 2}{2} \right\rfloor$.
        \item Начнем с $i = i_{\text{last}}$ и будем выполнять \texttt{SiftDown} для всех узлов с индексами от $i$ до $0$.
        \item Однако исходные узлы в позиции от $0$ до $n - 1$ уже удовлетворяют свойству кучи относительно своих поддеревьев, поэтому нам достаточно обработать только узлы, которые могут быть затронуты новыми элементами.
        \item Но чтобы гарантировать корректность, мы все же выполним \texttt{SiftDown} для всех узлов от $i_{\text{start}}$ до $0$, где $i_{\text{start}}$ — минимальный индекс узла, который является предком новых элементов.
        \item Поскольку глубина дерева кучи составляет $O(\log n)$, то количество таких узлов $O(\log n)$.
    \end{itemize}

    \textbf{Анализ временной сложности:}

    \begin{itemize}
        \item Количество узлов, для которых нужно выполнить \texttt{SiftDown}, составляет $O(\log n)$.
        \item В худшем случае время работы \texttt{SiftDown} для одного узла — $O(\log n)$.
        \item Таким образом, общая стоимость — $O(\log n \cdot \log n) = O(\log^2 n)$.
        \item Добавляем время, необходимое для обработки новых элементов (которое в данном случае $O(1)$, так как мы не выполняем операций над ними).
        \item Итого, общая временная сложность: $O(k + \log^2 n)$, так как $k$ может быть меньше $\log^2 n$.
    \end{itemize}

    \textbf{Часть 2: Преобразование за время $O(k + \log n \log \log n)$.}

    Чтобы улучшить временную сложность, необходимо оптимизировать операцию \texttt{SiftDown}. Для этого мы можем использовать следующее:

    \begin{enumerate}
        \item \textbf{Использование турниров:} Представим процесс восстановления кучи как серию турниров между узлами.
        \item \textbf{Оптимизация \texttt{SiftDown}:} Улучшим время работы \texttt{SiftDown} до $O(\log \log n)$ при определенных условиях.
    \end{enumerate}

    \textbf{Алгоритм:}

    \begin{enumerate}
        \item Разобьем кучу на блоки, размер которых зависит от $\log n$.
        \item В каждом блоке используем специальную структуру данных, позволяющую выполнять операции за $O(\log \log n)$.
        \item Выполним \texttt{SiftDown} с использованием этих структур.
    \end{enumerate}

    \textbf{Анализ временной сложности:}

    \begin{itemize}
        \item Количество узлов, для которых нужно выполнить \texttt{SiftDown}, остается $O(\log n)$.
        \item Время работы \texttt{SiftDown} для одного узла уменьшается до $O(\log \log n)$.
        \item Общая стоимость: $O(\log n \cdot \log \log n)$.
        \item Добавляем время на обработку новых элементов: $O(k)$.
        \item Итого, временная сложность: $O(k + \log n \log \log n)$.
    \end{itemize}

\end{solution}

\end{document}