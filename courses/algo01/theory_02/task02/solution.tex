\newcommand{\groupnumber}{1}

\documentclass[11pt]{article}

\usepackage{hometask}
\usepackage{amsfonts}
\usepackage{expdlist}
\usepackage{cmap}  % should be before fontenc
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\newcommand{\E}{\ensuremath{\mathsf{E}}}  % матожидание
\newcommand{\D}{\ensuremath{\mathsf{D}}}  % дисперсия
\newcommand{\Prb}{\ensuremath{\mathsf{P}}}  % вероятностная мера

\newcommand{\eps}{\varepsilon}  % эпсилон
\renewcommand{\phi}{\varphi}    % фи

\renewcommand{\le}{\leqslant}   % <=
\renewcommand{\leq}{\leqslant}  % <=
\renewcommand{\ge}{\geqslant}   % >=
\renewcommand{\geq}{\geqslant}  % >=

\begin{document}

\begin{problem}{25}
Фиксируем натуральное $k$.
Предложите структуру данных, способную выполнять два действия: \texttt{Enqueue}$(x)$~--- принять на вход ключ $x$; \texttt{Get-Kth}$()$~---
найти $k$-ю порядковую статистику среди принятых ключей. Учетная сложность \texttt{Enqueue} должна быть $O(1)$,
сложность \texttt{Get-Kth}~--- $O(k)$ в худшем случае.
Совет: группируйте вставки, используйте линейный алгоритм нахождения порядковой статистики.
\end{problem}

\begin{solution}
    Для фиксированного натурального числа $k$ требуется разработать структуру данных, поддерживающую операции \texttt{Enqueue}$(x)$ и \texttt{Get-Kth}$()$ с заданными ограничениями на временную сложность.

    \textbf{Описание структуры данных:}

    Будем поддерживать следующие компоненты:

    \begin{enumerate}
        \item Массив $S$ размером не более $k$, содержащий $k$ наименьших элементов среди всех принятых на данный момент ключей. Массив $S$ поддерживается в отсортированном порядке.
        \item Буфер $B$, представляющий собой неупорядоченный список элементов, поступивших через операции \texttt{Enqueue}, но ещё не обработанных.
    \end{enumerate}

    \textbf{Операция \texttt{Enqueue}$(x)$:}

    \begin{enumerate}
        \item Добавить элемент $x$ в буфер $B$.
        \item Если после добавления размер буфера $|B| = k$, выполнить процедуру обработки буфера:
              \begin{enumerate}
                  \item Объединить множества $S$ и $B$, получив множество $S \cup B$ размера не более $2k$.
                  \item Найти $k$ наименьших элементов в объединённом множестве $S \cup B$ с помощью линейного алгоритма нахождения порядковой статистики.
                  \item Обновить массив $S$, сохранив в нём найденные $k$ наименьших элементов в отсортированном порядке.
                  \item Очистить буфер $B$.
              \end{enumerate}
    \end{enumerate}

    \textbf{Операция \texttt{Get-Kth}$()$:}

    \begin{enumerate}
        \item Если буфер $B$ не пуст ($|B| > 0$), выполнить процедуру обработки буфера (аналогично пункту 2 в операции \texttt{Enqueue}).
        \item После гарантии того, что все элементы обработаны, вернуть максимальный элемент из массива $S$, который соответствует $k$-й порядковой статистике среди всех принятых ключей.
    \end{enumerate}

    \textbf{Анализ временной сложности:}

    \textit{Операция \texttt{Enqueue}$(x)$:}

    Каждая вставка элемента в буфер $B$ выполняется за $O(1)$. Обработка буфера происходит после каждых $k$ вставок и занимает $O(k)$ времени (объяснение ниже). Таким образом, амортизированная стоимость одной операции \texttt{Enqueue} составляет
    \[
        O(1) + \frac{O(k)}{k} = O(1).
    \]

    \textit{Операция \texttt{Get-Kth}$()$:}

    В худшем случае требуется обработать буфер $B$, что занимает $O(k)$ времени. После обработки буфера доступ к элементу в массиве $S$ выполняется за $O(1)$, так как массив отсортирован и размер его не более $k$. Таким образом, общая временная сложность операции \texttt{Get-Kth}$()$ составляет $O(k)$.

    \textit{Обоснование обработки буфера за $O(k)$:}

    \begin{itemize}
        \item Объединение множеств $S$ и $B$ занимает $O(k)$, так как размеры $|S| \leq k$ и $|B| = k$.
        \item Нахождение $k$ наименьших элементов в множестве размера не более $2k$ можно выполнить за $O(k)$ времени с помощью алгоритма поиска $k$-й порядковой статистики за линейное время (например, алгоритм медианы медиан).
        \item Сортировка этих $k$ элементов для поддержки массива $S$ в отсортированном виде занимает $O(k \log k)$, но поскольку $k$ считается константой, то $O(k \log k) = O(k)$.
    \end{itemize}
\end{solution}

\end{document}