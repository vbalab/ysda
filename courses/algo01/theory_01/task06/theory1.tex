\newcommand{\groupnumber}{1}

\documentclass[11pt]{article}

\usepackage{hometask}
\usepackage{amsfonts}
\usepackage{expdlist}
\usepackage{cmap}  % should be before fontenc
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\newcommand{\E}{\ensuremath{\mathsf{E}}}  % матожидание
\newcommand{\D}{\ensuremath{\mathsf{D}}}  % дисперсия
\newcommand{\Prb}{\ensuremath{\mathsf{P}}}  % вероятностная мера

\newcommand{\eps}{\varepsilon}  % эпсилон
\renewcommand{\phi}{\varphi}    % фи

\renewcommand{\le}{\leqslant}   % <=
\renewcommand{\leq}{\leqslant}  % <=
\renewcommand{\ge}{\geqslant}   % >=
\renewcommand{\geq}{\geqslant}  % >=

\begin{document}

\begin{problem}{20}
Предложите реализацию \emph{очереди} на основе (одного) массива, которая поддерживает операции добавления в конец и удаления из начала. Требуется, чтобы емкость очереди в любой момент времени отличалась от фактического размера не более чем в константу раз, а учетная сложность операций добавления в конец и удаления из начала была константной.
\end{problem}

\begin{solution}
	Также используем \textbf{метод банкира} (accounting method).

	Для реализации очереди на основе одного массива, которая поддерживает добавление в конец (\texttt{enqueue}) и удаление из начала (\texttt{dequeue}), используем динамический массив с циклическим буфером и динамическим изменением размера.

	Используем два указателя: \texttt{front}, указывающий на начало очереди, и \texttt{rear}, указывающий на следующий доступный для добавления элемент. Начальная емкость равна \(1\).

	При добавлении (\texttt{enqueue}), если массив заполнен, удваиваем его емкость. Элементы копируем в новый массив так, чтобы \texttt{front} всегда был на позиции \(0\). Это требует \(n\) операций, где \(n\) — текущий размер очереди. Назначаем амортизированную стоимость добавления в \(3\) единицы, где \(1\) покрывает само добавление, а \(2\) идут в "кредит" на удвоение емкости в будущем. Накопленный кредит \(2n\) с предыдущих добавлений покрывает затраты на копирование при увеличении размера.

	При удалении (\texttt{dequeue}), если после удаления размер становится равным четверти емкости, уменьшаем емкость вдвое и копируем элементы, что требует \(n\) операций. Амортизированная стоимость удаления также равна \(3\). При обычном удалении используется \(1\) единица на перемещение \texttt{front}, а \(2\) идут в "кредит". Эти \(2n\) единиц кредита покрывают затраты на уменьшение емкости, когда это необходимо.

	Для циклического массива \texttt{enqueue} и \texttt{dequeue} могут обходить конец массива с помощью операции по модулю. Это позволяет эффективно использовать всю емкость.

	Таким образом, амортизированная сложность операций \texttt{enqueue} и \texttt{dequeue} — \(O(1)\), так как кредит с дешевых операций компенсирует редкие дорогостоящие операции изменения размера. Емкость очереди всегда остаётся в константное количество раз больше фактического размера.

\end{solution}

\end{document}