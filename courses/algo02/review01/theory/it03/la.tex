\documentclass{article}

\usepackage[a4paper, margin=0.75in]{geometry} % Adjust margin here
\usepackage{cmap}  % should be before fontenc
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[pdftex,colorlinks=true,linkcolor=blue,urlcolor=red,unicode=true,hyperfootnotes=false,bookmarksnumbered]{hyperref}
\usepackage{indentfirst}

\newtheorem{lemma}{Лемма}  % создаёт команд для лемм
\newtheorem{theorem}{Теорема}  % создаёт команд для теорем

\newcommand{\E}{\ensuremath{\mathsf{E}}}  % матожидание
\newcommand{\D}{\ensuremath{\mathsf{D}}}  % дисперсия
\newcommand{\Prb}{\ensuremath{\mathsf{P}}}  % вероятностная мера

\newcommand{\eps}{\varepsilon}  % эпсилон
\renewcommand{\phi}{\varphi}    % фи

\renewcommand{\le}{\leqslant}   % <=
\renewcommand{\leq}{\leqslant}  % <=
\renewcommand{\ge}{\geqslant}   % >=
\renewcommand{\geq}{\geqslant}  % >=

\pagestyle{myheadings}
\markright{Владислав Балабаев, vbalab\hfill}

\begin{document}

\section{Алгоритм решения}

\begin{enumerate}
    \item $P$ разбивается символами <<?>> на $k$ непустых подстрок $P_1, P_2, \ldots, P_k$. Для каждой подстроки $P_i$ сохраняем её смещение $shift_i$ от конца образца, т.е. количество символов (включая <<?>>) между концом $P_i$ и концом $P$.

    \item Построение бора и суффиксных ссылок на $\{P_1, \ldots, P_k\}$. Делаем \textbf{Ахо–Корасик}.

    \item Каждая вершины бора - конец подстроки, держит индекс подстроки в массиве $\{P_1, \ldots, P_k\}$.

    \item Массив счётчиков $Count[0 \ldots |T| - 1] := 0$, где $Count[i]$ - сколько из $k$ подстрок совпали на позиции $i$ текста.

    \item Проходим $T$ по бору. Если при индекс текущего символа в тексте $j$ вершина соответствует концу $P_i$, увеличиваем $Count[j + shift_i]$ на 1.

    \item Итоговые индексы $i$, т.ч. $Count[i - |P| + 1] = k$ и $i - |P| + 1 \geq 0$, соответствуют позициям начала вхождений образца $P$ в текст $T$.
\end{enumerate}

При этом, достаточно кольцевого буфера длины $|P|$ заместо массива $Count$ длины $|T|$, поскольку на каждой итерации алгоритм обновляет только одну позицию, соответствующую текущему окну длины $|P|$.

\section{Корректность}

\begin{theorem}
    $T[i \ldots i + |P| - 1]$ является вхождением образца $P$, если и только если:

    \begin{enumerate}
        \item Для каждой подстроки $P_j$ существует точное вхождение $P_j$ в $T$ на позиции $i + |P| - shift_j - |P_j|$.

        \item Cимволы $T[i \ldots i + |P| - 1]$, не покрытые подстроками $P_j$ являются
              <<?>>.
    \end{enumerate}
\end{theorem}

\begin{proof}
    \textbf{Необходимость.}
    Пусть подстрока $S = T[i \dots i + |P| - 1]$ действительно совпадает с образцом $P$, учитывая, что символы <<?>> могут принимать любые значения. Тогда каждая фиксированная часть $P_j$ должна найти точное вхождение в $S$ на отрезке
    \[
        i + |P| - shift_j - |P_j|\;\dots\;i + |P| - shift_j - 1,
    \]
    что эквивалентно точному совпадению $P_j$ в тексте $T$ на позиции $i + |P| - shift_j - |P_j|$. Остальные позиции в $S$ соответствуют символам <<?>> и поэтому не накладывают дополнительных ограничений.

    \medskip

    \textbf{Достаточность.}
    Предположим теперь, что для каждого $j=1,\dots,k$ имеется точное совпадение $P_j$ в указанных выше позициях, а все остальные символы в $S$ могут быть произвольными. Тогда из определения символа <<?>> следует, что эти «нежёсткие» позиции не препятствуют полному совпадению $S$ с $P$. Следовательно, $S$ является вхождением $P$ в текст.
\end{proof}

Таким образом, если $Count[i] = k$, то это означает, что каждая подстрока $P_j$ сопоставилась с нужной позицией относительно начала вхождения, а значит, $P$ сопоставим с $T[i \ldots i + |P| - 1]$.

\section{Временная сложность}
Построение бора и суффиксных ссылок для $k$ строк суммарной длины $O(|P|)$ выходит в $O(|P|)$, поиск в тексте $T$ осуществляется за $O(|T| + |R|)$, где $|R|$ - длина ответа поиска, которое зависит от общего количество найденных вхождений в тексте, максимальное значение которого ограничевается количеством всех образцов на каждый символ текста. Количество образцов зависит напрямую зависит от количества символов <<?>>, допустим $|Q|$, откуда $\max{|R|}= |T| (|Q| + 1)$, из чего Ахо-Корасик имеет сложность $O(|T||Q|)$ $\to$ $O(|P| + |T||Q|)$ - общая сложность по времени.

\section{Затраты по памяти}
Бор - $O(|P|)$, кольцевой буфер - $O(|P|)$, структуры данных Ахо–Корасика - $O(|P|)$ $\to$ $O(|P|)$ - итоговая пространственная сложность алгоритма.

\end{document}
